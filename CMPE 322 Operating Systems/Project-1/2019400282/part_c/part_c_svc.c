/**
 * @file part_c_svc.c
 * This file is created by rpcgen. This file contains the main code of the server and the one
 * of the driver code of the server (as far as I understand). I edited this code so that it can
 * serve as a client for the logger program. Logs that will be logged to the log file are determined 
 * in the file part_c_server.c, here using them, we construct a whole string in the format
 * "<first number> <second number> <result>". Here, we create a socket and send that whole string
 * to the server that logger runs.
 * 
 * I used the explanation and the code snippet from this address:
 * https://www.geeksforgeeks.org/udp-server-client-implementation-c/
 * 
 * (This code is first generated by rpcgen and then modified by me for socket programming. It contains a lot of
 * technical details that I couldn't fully understand, so some explanations may be missed. I just commented the
 * parts that I added.)
 * 
 * How to compile and run Part C (A makefile is provided with the code):
 *  make
 *  ./part_c_logger.out <log file> <PORT_NUMBER> &
 *  ./part_c_server.out <LOGGER_IP_ADDRESS> <PORT_NUMBER> &
 *  ./part_c_client.out <path of the executable file> <output file> <SERVER_IP_ADDRESS>
 * 
 */

#include "part_c.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

// These variables are declared as global since they are used in both main function and part_c_prog_1:
char whole_log[MAXLINE]; // Whole log that is constructed by concatenating num1_log, num2_log and the result_log
int sockfd; // Socket file descriptor
struct sockaddr_in servaddr; // Address of the server.

static void
part_c_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		part_c_struct part_c_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case part_c:
		_xdr_argument = (xdrproc_t) xdr_part_c_struct;
		_xdr_result = (xdrproc_t) xdr_part_c_result;
		local = (char *(*)(char *, struct svc_req *)) part_c_1_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}

	strncpy(whole_log, "", sizeof(whole_log)); // Here, whole_log is initialized to an empty string.
	// Then by concatenating num1_log, num2_log and result_log, whole log line is created.
	strcat(whole_log, num1_log);
	strcat(whole_log, " ");
	strcat(whole_log, num2_log);
	strcat(whole_log, " ");
	strcat(whole_log, result_log);

	// By this function, whole_log is sent to the logger which runs in the given IP address.
	sendto(sockfd, (const char *)whole_log, strlen(whole_log), MSG_CONFIRM, (const struct sockaddr *) &servaddr,
			sizeof(servaddr));
	return;
}

int
main (int argc, char **argv)
{
	const char* IP_ADDRESS = argv[1]; // First argument is the IP address of the logger.
	int PORT = atoi(argv[2]); // Second argument is the port number that we will bind to.

	// Socket file descriptor is created:
	if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
		// In case of a failure, error message is printed to the console.
		perror("socket creation failed");
		exit(EXIT_FAILURE);
	}

	// Initializing the server address:
	memset(&servaddr, 0, sizeof(servaddr));
	
	// Filling server information:
	servaddr.sin_family = AF_INET; // We use IPv4. Here, we state that.
	servaddr.sin_port = htons(PORT); // This is the port of the server which we will bind to.

	// Here, if IP addres is given as "localhost" in the arguments, I need to correct this to a
	// full IPv4 address. Otherwise, we set the IP address accordingly.
    if(strcmp(IP_ADDRESS, "localhost") == 0){
        servaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    } else{
        servaddr.sin_addr.s_addr = inet_addr(IP_ADDRESS);
    }
	// After these steps, whole server address is constructed.

	register SVCXPRT *transp;

	pmap_unset (PART_C_PROG, PART_C_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, PART_C_PROG, PART_C_VERS, part_c_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (PART_C_PROG, PART_C_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, PART_C_PROG, PART_C_VERS, part_c_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (PART_C_PROG, PART_C_VERS, tcp).");
		exit(1);
	}

	// close(sockfd); // close socket
	svc_run (); // Running the server.
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
