/**
 * @file part_b_server.c
 * @author Halil Burak Pala
 * @date December 2021
 * @brief A server program which runs an RPC function requested from a client.
 * 
 * This program is the implementation of the Server of the Part B of the CmpE 322 Project 1 in the 
 * Fall 2021 semester.
 * This server creates a child process which runs the requested RPC function. Implementation is 
 * very much alike with the Part A of the project. But this time, client calls the server by passing
 * the necessary numbers and the path of the executable file. The rest is similar. Parent process creates
 * a child process which executes the requested executable by sending inputs via a pipe, and child
 * sends the output via pipes according to whether the output is from stdin or stderr.
 * 
 * (This code is first generated by rpcgen and then modified by me. I could not fully understand some
 * techincal details generated by rpcgen.)
 * 
 * How to compile and run Part B (A makefile is provided with the code):
 * 	make
 * 	./part_b_server.out &
 * 	./part_b_client.out <path of the executable file> <output file> <SERVER_IP_ADDRESS>
 */
#include "part_b.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
 
#define INT_BUFFER_SIZE 12 // Given integer input can be at most 11 characters (longest integer is -2147483648)
#define ERR_BUFFER_SIZE 10000 // Max buffer size for the error message
#define READ_END	0 
#define WRITE_END	1 

/**
 * @brief Driver code for the server.
 * 
 * @param argp This struct contains the arguments given by the client.
 * @param rqstp (No information)
 * @return part_b_result* The result which will then be sent to the client.
 */
part_b_result *
part_b_1_svc(part_b_struct *argp, struct svc_req *rqstp)
{
	/**
	 * The "result" struct will be sent to the client. It has four member variables:
	 * 	result->is_out: This variable is a boolean which will be true if the output is given via stdout by 
	 * 					the RPC function.
	 * 	result->is_err: This variable is a boolean which will be true if the output is given via stderr by 
	 * 					the RPC function.
	 *  result->out:	This variable is a string which will contain the output message given via stdout.
	 *  result->err:	This variable is a string which will contain the output message given via stderr.
	 */
	static part_b_result  result;
	static char out_msg[INT_BUFFER_SIZE]; // Output message from stdout of the RPC function.
	static char err_msg[ERR_BUFFER_SIZE]; // Output message from stderr of the RPC function.

	memset(&result, '\0', sizeof(part_b_result));                                
	memset(out_msg, '\0', sizeof(out_msg)); 
	memset(err_msg, '\0', sizeof(err_msg));

	// Initializing the result.
	result.out = out_msg;
	result.err = err_msg;
	result.is_out = FALSE;
	result.is_err = FALSE;

	// Arguments given by the client.
	char* blackbox = argp->blackbox; // Path of the executable file.
	int num1 = argp->num1; // Number 1
	int num2 = argp->num2; // Number 2

	// For converting numbers num1 and num2 to strings:
	char str_num1[INT_BUFFER_SIZE]; 
	char str_num2[INT_BUFFER_SIZE];
	sprintf(str_num1, "%d", num1);
	sprintf(str_num2, "%d", num2);

    int pipe1[2];   // This pipe is for sending data from the parent to the child.
                    // This pipe's read end will be connected to the child, its write end 
                    // will be connected to the stdin of the child. (P >===> C)

    int pipe2[2];   // This pipe's read end will be connected to the parent, its write end 
                    // will be connected to the stdout of the child. (P <===< C)

    int pipe3[2];   // This pipe's read end will be connected to the parent, its write end
                    // will be connected to the stderr of the child. (P <===< C)

	// Creating the pipes:
	pipe(pipe1);
    pipe(pipe2);
    pipe(pipe3);

    pid_t pid;
    pid = fork();

	if(pid > 0){
		/**
         * This is the code for the parent process.
         */

        /**
         * The parent should close the ends of the pipes that it will not use.
         */
        close(pipe1[READ_END]);
        close(pipe2[WRITE_END]);
        close(pipe3[WRITE_END]);

		char str[2*INT_BUFFER_SIZE] = "\0"; // We will send given integers to the child process in the format 
                                            // "<num1> <num2>". We will construct this format in this str variable.
                                            // It will be taken from stdin of the child process.
		strcat(str,str_num1); // str is "<num1>"
        strcat(str," "); // str is "<num1> "
        strcat(str,str_num2); // str is "<num1> <num2>"

        write(pipe1[WRITE_END], str, strlen(str)+1); // We send these numbers to the child process by this pipe.
        
        close(pipe1[WRITE_END]); // Then we close the pipe.

        wait(NULL); // Wait until the chil process is done.

		if(read(pipe2[READ_END], out_msg, INT_BUFFER_SIZE)){
			/**
             * If the resultant integer is successfully read to the string out_msg, is_out of the result is set 
			 * to TRUE and out_msg is set as the out (Output) of the result. 
             */
			result.is_out = TRUE;
			result.out = out_msg;
		}

		if(read(pipe3[READ_END], err_msg, ERR_BUFFER_SIZE)){
			/**
             * If the error message is read to the string err_msg instead of a result from stdout, is_err of the 
			 * result is set to TRUE and err_msg is set as the err (Error message) of the result. 
             */
			result.is_err = TRUE;
			result.err = err_msg;
		}

		close(pipe2[READ_END]);
        close(pipe3[READ_END]);
	}
	else if(pid == 0){
		/**
         * This is the code for the child process
         */

        /**
         * The child should close the ends of the pipes that it will not use.
         */
		close(pipe1[WRITE_END]);
        close(pipe2[READ_END]);
        close(pipe3[READ_END]);

        dup2(pipe1[READ_END], STDIN_FILENO); // Read end of the pipe1 is connected to the stdin.
        close(pipe1[READ_END]);

        dup2(pipe2[WRITE_END], STDOUT_FILENO); // Write end of the pipe2 is connected to the stdout.
        close(pipe2[WRITE_END]);

        dup2(pipe3[WRITE_END], STDERR_FILENO); // Write end of the pipe3 is connected to the stderr.
        close(pipe3[WRITE_END]);

        execlp(blackbox, blackbox, NULL); // Child executes the given executable file.
	}

	// Returns the result to client.
	return &result;
}
